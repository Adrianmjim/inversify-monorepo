---
sidebar_position: 4
title: Decorator
---
import decoratorApiInjectConstructorArgumentSource from '@inversifyjs/code-examples/generated/examples/decoratorApiInjectConstructorArgument.ts.txt';
import decoratorApiInjectPropertySource from '@inversifyjs/code-examples/generated/examples/decoratorApiInjectProperty.ts.txt';
import decoratorApiMultiInjectPropertySource from '@inversifyjs/code-examples/generated/examples/decoratorApiMultiInjectProperty.ts.txt';
import decoratorApiNamedSource from '@inversifyjs/code-examples/generated/examples/decoratorApiNamed.ts.txt';
import decoratorApiOptionalSource from '@inversifyjs/code-examples/generated/examples/decoratorApiOptional.ts.txt';
import decoratorApiPostConstructSource from '@inversifyjs/code-examples/generated/examples/decoratorApiPostConstruct.ts.txt';
import decoratorApiPreDestroySource from '@inversifyjs/code-examples/generated/examples/decoratorApiPreDestroy.ts.txt';
import decoratorApiTaggedSource from '@inversifyjs/code-examples/generated/examples/decoratorApiTagged.ts.txt';
import decoratorApiUnmanagedSource from '@inversifyjs/code-examples/generated/examples/decoratorApiUnmanaged.ts.txt';
import CodeBlock from '@theme/CodeBlock';

# Decorators

This section covers inversify decorators used to provide class metadata.

## injectable

Decorator used to set class metadata so containers can receive class emitted metadata.

It's highly recommended to annotate every class provided as a service with the injectable decorator. Having said that, it's not mandatory in every single case.

### When is injectable mandatory?

Basically, whenever class emitted metadata is expected.

Consider the following sample code:

```ts
import 'reflect-metadata';
import { injectable } from 'inversify';

@injectable()
class B {
  readonly foo: string = 'foo';
}

@injectable()
class A {
  constructor(public readonly b: B) {}
}
```

A commonJS transpilation with [emitDecoratorMetadata](https://www.typescriptlang.org/tsconfig/#emitDecoratorMetadata) option enabled might look like this:

```js
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const inversify_1 = require("inversify");
let B = class B {
    foo = 'foo';
};
B = __decorate([
    (0, inversify_1.injectable)()
], B);
let A = class A {
    b;
    constructor(b) {
        this.b = b;
    }
};
A = __decorate([
    (0, inversify_1.injectable)(),
    __metadata("design:paramtypes", [B])
], A);
```

Typescript emits class metadata if and only if there're any class decorators applied to the target class. If we remove the `injectable` from `A`, the transpiled code looks way different:

```js
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
class B {
    foo = 'foo';
}
class A {
    b;
    constructor(b) {
        this.b = b;
    }
}
```

This time no class metadata is emitted even if `emitDecoratorMetadata` typescript option is enabled, causing trouble at execution time.

## inject

Decorator used to establish a relation between a constructor argument or a class property and a service id.

When resolving an instance of the class, the target constructor argument or property will be resolved in the same way [container.get](/docs/api/container#get) behaves.

### Example: decorating a class constructor argument

<CodeBlock language="ts">{decoratorApiInjectConstructorArgumentSource}</CodeBlock>

### Example: decorating a property

<CodeBlock language="ts">{decoratorApiInjectPropertySource}</CodeBlock>

## multiInject

Decorator used to establish a relation between a constructor argument or a class property and a service id.

When resolving an instance of the class, the target constructor argument or property will be resolved in the same way [container.getAll](/docs/api/container#getall) behaves with the `enforceBindingConstraints` flag enabled.

### Example: decorating a property

<CodeBlock language="ts">{decoratorApiMultiInjectPropertySource}</CodeBlock>

## named

Decorator used to establish a relation between a constructor argument or a class property and a metadata name.

<CodeBlock language="ts">{decoratorApiNamedSource}</CodeBlock>

## optional

Decorator used to establish a target constructor argument or property is optional and, therefore, it shall not be resolved if no bindings are found for the associated service id.

<CodeBlock language="ts">{decoratorApiOptionalSource}</CodeBlock>

## postConstruct

Decorator used to establish an activation handler for the target class. Consider [docs](/docs/fundamentals/lifecycle/activation) as reference.

<CodeBlock language="ts">{decoratorApiPostConstructSource}</CodeBlock>

## preDestroy

Decorator used to establish a deactivation handler for the target class. Consider [docs](/docs/fundamentals/lifecycle/deactivation) as reference.

<CodeBlock language="ts">{decoratorApiPreDestroySource}</CodeBlock>

## tagged

Decorator used to establish a relation between a constructor argument or a class property and a metadata tag.

<CodeBlock language="ts">{decoratorApiTaggedSource}</CodeBlock>

## targetName
Decorator used to establish a relation between a constructor argument or a class property name at design time.

Bundlers might minify code, altering class property names. This decorator keeps track of the original name.

This property is kept in the `name` property of the `target` request in a binding constraint.

```ts
@injectable()
class Ninja implements Ninja {
  public katana: Weapon;
  public shuriken: Weapon;
  constructor(
      @inject("Weapon") @targetName("katana") katana: Weapon,
      @inject("Weapon") @targetName("shuriken") shuriken: Weapon
  ) {
      this.katana = katana;
      this.shuriken = shuriken;
  }
}

container.bind<Weapon>("Weapon").to(Katana).when((request: interfaces.Request) => {
  return request.target.name.equals("katana");
});
```

## unmanaged

Decorator used to establish inversify should not inject the target constructor argument or property whatsoever.

<CodeBlock language="ts">{decoratorApiUnmanagedSource}</CodeBlock>
